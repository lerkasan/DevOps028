- name: Configure developer environment with JDK and PostgreSQL
# hosts: ansible_vagrant
  hosts: all
  become: yes
  become_user: root
  vars_files:
    - ../conf/variables.yml
    - ../conf/vault.yml
  tasks:
    - name: Install pip
      apt:
        pkg: ['python3-pip', 'python-pip']
        update_cache: yes
        state: present

    - name: Install boto3
      pip:
        name: boto3

    - name: Check if JDK8 is already downloaded
      stat: path={{ files_dir }}/jdk8.tar.gz
      register: jdk8_exists

    - name: Download JDK8 from AWS S3 bucket
      aws_s3:
        bucket={{ s3.bucket_name }}
        region={{ s3.aws_region }}
        aws_access_key={{ aws_access_key }}
        aws_secret_key={{ aws_secret_key }}
        object={{ s3.jdk_filename }}
        dest={{ files_dir }}/jdk8.tar.gz
        mode=get
        overwrite=True
        retries={{ s3.retries }}
      when: jdk8_exists.stat.exists == False

    - name: Create directory for extracted JDK8
      file:
        path={{ jdk.path }}
        state=directory
        mode=0755

    - name: Extract downloaded JDK8 tar.gz archive
      unarchive:
        src: "{{ files_dir }}/jdk8.tar.gz"
        dest: "{{ jdk.path }}"
        remote_src: yes

    - name: Find exact path to extracted JDK
      shell: "find '{{ jdk.path }}' -name java | grep -v openjdk | head -n 1 | rev | cut -c 10- | rev"
      register: jdk_home

#    - debug: msg="JDK_HOME path = '{{ jdk_home.stdout }}'"

    - name: Add JAVA_HOME variable to /etc/environment file
      lineinfile:
        path: /etc/environment
        regexp: '^JAVA_HOME'
        line: 'JAVA_HOME={{ jdk_home.stdout }}'
        owner: root
        group: root
        mode: 0644

    - name: Install Maven, PostgreSQL, Python-Pip and MC
      apt:
        pkg: ['maven', 'postgresql', 'python-psycopg2', 'mc']
        update_cache: yes
        cache_valid_time: 3600

    - name: Make java from downloaded JDK8 prime alternative with the highest priority
      alternatives:
        name: java
        link: /usr/bin/java
        path: "{{ jdk_home.stdout }}/bin/java"
        priority: 30000

# Started causing error file not found, however javac file exists in extracted folder
#    - name: Make javac from downloaded JDK8 prime alternative with the highest priority
#      alternatives:
#        name: javac
#        link: /usr/bin/javac
#        path: "{{ jdk_home.stdout }}/bin/javac"
#        priority: 30000

    - name: Create an AWS RDS instance
      rds_instance:
        db_instance_identifier: "{{ rds.instance }}"
        db_instance_class: "{{ rds.class }}"
        allocated_storage: "{{ rds.storage_size }}"
        db_name: "{{ db.name }}"
        region: "{{ rds.aws_region }}"
        engine: "{{ rds.engine }}"
        username: "{{ db.user }}"
        password: "{{ db.password }}"
        publicly_accessible: yes
        skip_final_snapshot: yes
        aws_access_key: "{{ aws_access_key }}"
        aws_secret_key: "{{ aws_secret_key }}"
      when: database_location == "aws_rds"

    - name: Get information about an RDS instance
      rds_instance_info:
        db_instance_identifier: "{{ rds.instance }}"
        region: "{{ rds.aws_region }}"
        aws_access_key: "{{ aws_access_key }}"
        aws_secret_key: "{{ aws_secret_key }}"
      register: rds_info
      when: database_location == "aws_rds"

    - name: Set database URL from AWS RDS as db_host variable
      set_fact:
        db_host: "{{ rds_info.instances[0].endpoint.address }}"
      when: database_location == "aws_rds"

    - name: Set vagrant machine private_network ip as db_host variable
      set_fact:
        db_host: "{{ vagrant_ip }}"
      when: database_location == "vagrant_local"

    - name: Generate application.properties from template using database endpoint variables
      template: src={{ app_props.template }} dest={{ app_props.properties }}
        mode=0644

    - name: Generate liquibase.properties from template using database endpoint variables
      template: src={{ liquibase.template }} dest={{ liquibase.properties }}
        mode=0644

    - name: Find PostgreSQL postgresql.conf configuration file path
      command: "find '/etc/postgresql' -name 'postgresql.conf'"
      register: postgres_conf_path
      when: database_location == "vagrant_local"

    - name: Find PostgreSQL pg_hba.conf configuration file path
      command: "find /etc/postgresql -name 'pg_hba.conf'"
      register: pg_hba_path
      when: database_location == "vagrant_local"

    - name: Add vagrant private_network IP-address as PostgreSQL listen_address
      become: true
      become_user: postgres
      postgresql_set:
        name: listen_addresses
        value: "{{ vagrant_ip }}, 127.0.0.1"
      when: database_location == "vagrant_local"

    - name: Add custom port as PostgreSQL listen_port
      become: true
      become_user: postgres
      postgresql_set:
        name: port
        value: "{{ db.port }}"
      when: database_location == "vagrant_local"

    - name: Add permission for DB_USER to connect to DB_NAME from host machine by IP from vagrant private_network
      postgresql_pg_hba:
        dest: "{{ pg_hba_path.stdout }}"
        databases: "{{ db.name }}"
        contype: host
        users: "{{ db.user }}"
        source: "{{ vagrant_ip }}/24"
        method: md5
      when: database_location == "vagrant_local"

    - name: Add permission for DB_USER to connect to DB_NAME from inside vagrant instance locally logined through ssh
      postgresql_pg_hba:
        dest: "{{ pg_hba_path.stdout }}"
        databases: "{{ db.name }}"
        contype: host
        users: "{{ db.user }}"
        source: "127.0.0.1/32"
        method: md5
      when: database_location == "vagrant_local"

    - name: Restart PostgreSQL
      service:
        name: postgresql
        state: restarted
      when: database_location == "vagrant_local"

    - name: Create PostgreSQL database
      become: true
      become_user: postgres
      postgresql_db:
        name: "{{ db.name }}"
        encoding: UTF-8
        lc_collate: en_US.UTF-8
        lc_ctype: en_US.UTF-8
        template: template0
      when: database_location == "vagrant_local"

    - name: Create user for database connectivity
      become: true
      become_user: postgres
      postgresql_user:
        db: "{{ db.name }}"
        name: "{{ db.user }}"
        password: "{{ db.password }}"
        priv: "ALL"
      when: database_location == "vagrant_local"

    - name: Create directory where liquibase binaries will be downloaded
      file:
        path={{ liquibase.bin_dir }}
        state=directory
        mode=755

    - name: Download Liquibase binaries
      get_url:
        url: "{{ liquibase.download_url }}"
        dest: "{{ liquibase.bin_dir }}/liquibase-bin.tar.gz"
        mode: 0440

    - name: Extract downloaded Liquibase binaries from tar.gz archive
      unarchive:
        src: "{{ liquibase.bin_dir }}/liquibase-bin.tar.gz"
        dest: "{{ liquibase.bin_dir }}"
        remote_src: yes

    - name: Download PostgreSQL JDBC driver
      get_url:
        url: "{{ postgres_jdbc_driver_url }}"
        dest: "{{ liquibase.bin_dir }}/lib/postgresql-jdbc-driver.jar"
        mode: 0440

  # - name: Report error if there was a connectivity problem while downloading PostgreSQL JDBC driver
  #  fail:
  #    msg: 'Unable to download {{postgres_jdbc_driver_url}}: {{jdbc_driver_download_status.response|default(jdbc_driver_download_status.msg)}}'
  #  when: not jdbc_driver_download_status|succeeded

    - name: Symlink liquibase.properties files to Liquibase binary directory
      file:
        src: "{{ liquibase.bin_dir }}/../liquibase.properties"
        dest: "{{ liquibase.bin_dir }}/liquibase.properties"
        state: link

    - name: Update database using Liquibase
      shell: "cd {{ liquibase.bin_dir }} && ./liquibase update"

    - name: Create jar artifact using maven package
      shell: "cd {{ project_dir }} && mvn clean package"

    - name: Run Java appliation
      shell: "nohup java -jar {{ project_dir }}/target/*.jar > {{ project_dir }}/samsara.log  2>&1 &"
